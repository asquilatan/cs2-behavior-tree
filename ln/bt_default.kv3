<!-- kv3 encoding:text:version{e21c7f3c-8a33-41c5-9977-a76d3a32aa0d} format:generic:version{7412167c-06e9-4698-aff2-e63eb59037e7} -->
{
	config = "scripts/ai/ln/bt_config.kv3"
	root =
	{
		type = "decorator_bot_service"
		memory_to_expire =
		[
			{
				key = "ShortTermAttackMemory"
				time = 0.7
				distance = 0
			},
			{
				key = "LongTermMemory"
				time = 10
				distance = 0
			},
			{
				key = "ShortTermInvestigateMemory"
				time = 3
				distance = 0
			},
			{
				key = "HidingSpot"
				time = 10
				distance = 0
			}
		]
		child =
		{
			type = "decorator_buy_service"
			output = "ShouldBuy"
			child =
			{
				type = "parallel"
				children =
				[
					{
						type = "decorator_repeat"
						child =
						{
							type = "parallel"
							children =
							[
								// Global Wallhack Sensor
								{
									type = "decorator_sensor"
									shape =
									{
										type = "sensor_shape_sphere"
										radius = 20000
									}
									entity_type_filter = "PLAYERS"
									team_filter = "ENEMY"
									output = "WallhackEnemies"
									priority = 0
									child =
									{
										type = "decorator_memory"
										input = "WallhackEnemies"
										output = "ShortTermInvestigateMemory"
										child =
										{
											type = "decorator_memory"
											input = "WallhackEnemies"
											output = "LongTermMemory"
										}
									}
								},
								// memorize enemies through vision
								{
									type = "subtree"
									file = "scripts/ai/modules/bt_memorize_enemies_vision.kv3"
									name = "MemorizeEnemiesVision"
								},
								// memorize noises happening right now
								{
									type = "subtree"
									file = "scripts/ai/modules/bt_memorize_noises.kv3"
									name = "MemorizeNoises"
								},
								// record the nearest memorized event to investigate
								{
									type = "subtree"
									file = "scripts/ai/modules/bt_memorize_nearest_investigation.kv3"
									name = "MemorizeNearestInvestigation"
								}
							]
						}
					},
					{
						type = "decorator_repeat"
						child =
						{
							type = "selector"
							children =
							[
								// Buy if we have to
								{
									type = "condition_is_empty"
									input = "ShouldBuy"
									negated = 1
									child =
									{
										// sequencer: evaluate first to last child, in order
										type = "sequencer"
										children =
										[
											{
												type = "action_wait"
												wait_time_min = 0
												wait_time_max = 0
											},
											{
												type = "subtree"
												file = "scripts/ai/ln/modules/bt_buy_coordinated.kv3"
												name = "BuyCoordinated"
											},
											{
												type = "decorator_remove_key"
												input = "ShouldBuy"
											}
										]
									}
								},
								// Else: face the damage source if we're taking damage
								{
									type = "decorator_sensor"
									entity_type_filter = "DAMAGE"
									output = "Damage"
									shape =
									{
										type = "sensor_shape_sphere"
										radius = 20000
									}
									priority = 0
									child =
									{
										type = "condition_is_empty"
										input = "Damage"
										negated = 1
										child =
										{
											type = "action_aim"
											input = "Damage"
											acquire_only = 1
										}
									}
								},
								// Else: attack if we see an enemy
								{
									type = "subtree"
									file = "scripts/ai/ln/modules/bt_attack.kv3"
									name = "Attack"
								},
								{
									type = "subtree"
									file = "scripts/ai/modules/bt_heal_if_needed.kv3"
									name = "HealIfNeeded"
								},
								// Else: defuse the bomb if nearby (CT)
								{
									type = "subtree"
									file = "scripts/ai/ln/modules/bt_defuse_bomb_if_nearby.kv3"
									name = "DefuseBombIfNearby"
								},
								// Else: pickup the bomb if nearby (T)
								{
									type = "subtree"
									file = "scripts/ai/ln/modules/bt_pickup_bomb_if_nearby.kv3"
									name = "PickupBombIfNearby"
								},
								// Else: plant bomb if we have cover from friendlies (T)
								{
									type = "subtree"
									file = "scripts/ai/ln/modules/bt_plant_bomb_if_covered.kv3"
									name = "PlantBombIfCovered"
								},
								// Else: plant bomb if we own it (T)
								{
									type = "subtree"
									file = "scripts/ai/ln/modules/bt_plant_bomb_if_owned.kv3"
									name = "PlantBombIfOwned"
								},
								// Else: investigate the closest memorized event
								{
									type = "subtree"
									file = "scripts/ai/ln/modules/bt_investigate_wallhack.kv3"
									name = "InvestigateClosestMemorizedEvent"
								},
								// Else: Terrorists defend planted bomb (50% chance to stay at site)
								{
									type = "condition_is_equal"
									source = "TeamName"
									destination = "'T'"
									child =
									{
										type = "decorator_sensor"
										shape =
										{
											type = "sensor_shape_sphere"
											radius = 20000
										}
										entity_type_filter = "CLASSNAME"
										orphan_only = 1
										output = "PlantedBombT"
										class_name = "planted_c4"
										priority = 0
										child =
										{
											type = "condition_is_empty"
											input = "PlantedBombT"
											negated = 1
											child =
											{
												// 50% chance to stay and defend the bomb
												type = "decorator_random_int"
												min = 0
												max = 1
												output = "DefendRoll"
												child =
												{
													type = "sequencer"
													children =
													[
														{
															type = "condition_is_equal"
															source = "DefendRoll"
															destination = 0
														},
														// Move near the bomb area
														{
															type = "action_move_to"
															destination = "PlantedBombT"
															movement_type = "BT_ACTION_MOVETO_RUN"
															route_type = "BT_ACTION_MOVETO_FASTEST_ROUTE"
															arrival_epsilon = 1000
														},
														// Move to a hiding spot (if available)
														{
															type = "selector"
															children =
															[
																{
																	type = "sequencer"
																	children =
																	[
																		{
																			type = "action_hide"
																			max_range = 1500
																			output = "HidingSpot"
																		},
																		{
																			type = "action_move_to"
																			destination = "HidingSpot"
																			movement_type = "BT_ACTION_MOVETO_WALK"
																			route_type = "BT_ACTION_MOVETO_FASTEST_ROUTE"
																			arrival_epsilon = 50
																		}
																	]
																},
																// Fallback: just stay near the bomb
																{
																	type = "decorator_succeed"
																}
															]
														},
														// Look at the bomb
														{
															type = "action_look_at"
															input_location = "PlantedBombT"
														},
														// Wait and watch
														{
															type = "action_wait"
															wait_time_min = 2.0
															wait_time_max = 4.0
														}
													]
												}
											}
										}
									}
								},
								// Else: hunt
								{
									// sequencer: evaluate first to last child, in order
									type = "sequencer"
									children =
									[
										{
											type = "action_equip_weapon"
											weapon = "BEST"
										},
										{
											type = "decorator_random_int"
											min = 0
											max = 1
											output = "BombSiteIndex"
											child =
											{
												type = "action_choose_bomb_site_area"
												input = "BombSiteIndex"
												output = "HuntAreas"
											}
										},
										{
											type = "action_choose_team_spawn_area"
											output = "HuntAreas"
										},
										{
											type = "action_choose_random_waypoint"
											input = "HuntAreas"
											output = "TargetHuntArea"
										},
										// 50/50 chance to push (run) or lurk (walk)
										{
											type = "decorator_random_int"
											min = 0
											max = 1
											output = "LurkDecision"
											child =
											{
												type = "selector"
												children =
												[
													// Case 0: Lurk (Walk)
													{
														type = "sequencer"
														children =
														[
															{
																type = "condition_is_equal"
																source = "LurkDecision"
																destination = 0
															},
															{
																type = "action_move_to"
																destination = "TargetHuntArea"
																movement_type = "BT_ACTION_MOVETO_WALK"
																route_type = "BT_ACTION_MOVETO_FASTEST_ROUTE"
															}
														]
													},
													// Case 1: Push (Run)
													{
														type = "action_move_to"
														destination = "TargetHuntArea"
														movement_type = "BT_ACTION_MOVETO_RUN"
														route_type = "BT_ACTION_MOVETO_FASTEST_ROUTE"
													}
												]
											}
										}
									]
								}
							]
						}
					}
				]
			}
		}
	}
}
